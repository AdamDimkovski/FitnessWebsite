<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Workout Tracker</title>

  <link rel="icon" type="image/x-icon" href="images/favicon.png">
  <link rel="stylesheet" href="style-exercise.css">

  <!-- Charts.js -->
 <script src="https://cdn.jsdelivr.net/npm/chart.js/dist/chart.umd.min.js"></script>

  <!-- Firebase (compat version) -->
<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>

<script src="firebase.js"></script> 
<script src="exercise-data.js"></script>   
<script src="script.js"></script>    

</head>

<body>

  <!-- Navigation Bar -->
  <nav>
    <nav-content><a href="index.html">Home</a></nav-content>
    <nav-content><a href="calculator.html">Maintenance Calculator</a></nav-content>
    <nav-content><a href="food.html">Diet Tracker</a></nav-content>
    <nav-content><a href="exercise.html">Workout Tracker</a></nav-content>
    <nav-content id="signupLink"><a href="sign-up.html">Sign Up</a></nav-content>
    <nav-content id="loginLink"><a href="log-in.html">Log In</a></nav-content>
    <nav-content id="profileLink" style="display:none;"><a href="profile.html">Profile</a></nav-content>
    <nav-content id="logoutLink" style="display:none;"><a href="#">Log Out</a></nav-content>
  </nav>

  <!-- Pr Toast Div -->
  <div id="prToast" class="pr-toast"></div>

  <!-- PR Sound -->
  <audio id="prSound" src="sounds/PRping.mp3"></audio>

  <!-- Access Blocker Modal -->
  <div id="accessBlocker" style="display:none;" class="modal">
    <div class="modal-content">
      <h2>Must have Account to use this page.</h2>
      <p>Click the buttons below to log in or sign up!</p>
      <a href="sign-up.html"><button>Sign Up</button></a>
      <a href="log-in.html"><button>Log In</button></a>
    </div>
  </div>

  <h1><strong>Welcome back,</strong> <span id="profileName"></span></h1>
  <p>Track your workouts, monitor your strength, and watch your progress grow!</p>

    <!-- Workout Top Panel -->
    <section class="workout-top-panel">
      <h2>Create Workout</h2>

      <div class="form-row">
        <div class="form-group">
          <label for="workoutName">Workout Name</label>
          <input
            type="text"
            id="workoutName"
            placeholder="e.g., Push Day, Leg Day, Chest Strength"
          >
        </div>

        <div class="form-group">
          <label for="workoutDate">Workout Date</label>
          <input type="date" id="workoutDate">
        </div>
      </div>

      <div class="selected-exercises-panel">
        <h3>Selected Exercises</h3>
        <div id="selectedExercisesList"></div>
      </div>

      <div class="workout-buttons">
        <button id="openExerciseSelector" class="btn-primary">+ Add Exercises</button>
        <button id="saveWorkoutBtn" class="btn-save">Save Workout</button>
      </div>
    </section>

  <!-- Notes Modal -->
  <div id="notesModal" class="modal" style="display:none;">
    <div class="modal-content">
      <h3>Add Notes for <span id="modalExerciseName"></span></h3>
      <textarea id="exerciseNoteInput" placeholder="Enter notes..."></textarea>
      <button id="saveNoteBtn" class="btn-primary">Save</button>
      <button id="cancelNoteBtn" class="btn-secondary">Cancel</button>
    </div>
  </div>

  <!-- Personal Records Panel -->
<section class="pr-panel">
  <h2>Personal Records</h2>

  <input 
    type="text" 
    id="prSearch" 
    class="pr-search" 
    placeholder="Search exercises..."
  >

  <div id="prCategories"></div>
</section>

  <!-- Workout History -->
<section class="workout-history-container">
  <h2>Your Workout History</h2>
  <div id="historyYears"></div>
</section>

  <!-- Strength Progress Chart -->
<section class="progress-chart-container">
  <h2>Progress Analytics</h2>

  <select id="chartSelector" class="chart-selector">
    <option value="strength">Strength Progression</option>
    <option value="bodygroups">Most Used Body Groups</option>
  </select>

  <canvas id="progressChart"></canvas>
</section>

  <!-- Page Logic -->
  <script>

// User Name
async function loadUserName() {
  const user = auth.currentUser;
  if (!user) return;

  const doc = await db.collection("users").doc(user.uid).get();
  if (doc.exists) {
    document.getElementById("profileName").textContent = doc.data().name;
  }
}

// Load workout history with PR highlighting
    async function loadWorkoutHistory() {
    const user = auth.currentUser;
    if (!user) return;

    const snapshot = await db.collection("users")
      .doc(user.uid)
      .collection("workouts")
      .orderBy("date", "desc")
      .get();

    const container = document.getElementById("historyYears");
    container.innerHTML = "";

    if (snapshot.empty) {
      container.innerHTML = `<p style="color:#aaa;">No workouts logged yet.</p>`;
      return;
    }

    // Group by year → month
    const groups = {};

    snapshot.docs.forEach(doc => {
      const data = doc.data();
      const date = new Date(data.date);

      const year = date.getFullYear();
      const month = date.toLocaleString("default", { month: "long" });

      if (!groups[year]) groups[year] = {};
      if (!groups[year][month]) groups[year][month] = [];

      groups[year][month].push(data);
    });

    // Render years
    Object.keys(groups).forEach(year => {
      const yearDiv = document.createElement("div");
      yearDiv.className = "history-year";

      yearDiv.innerHTML = `
        <div class="history-year-header">
          <span>${year}</span>
          <span class="history-arrow">▶</span>
        </div>
        <div class="history-year-content"></div>
      `;

      const yearContent = yearDiv.querySelector(".history-year-content");

      // Render months inside year
      Object.keys(groups[year]).forEach(month => {
        const monthDiv = document.createElement("div");
        monthDiv.className = "history-month";

        monthDiv.innerHTML = `
          <div class="history-month-header">
            <span>${month}</span>
            <span class="history-arrow">▶</span>
          </div>
          <div class="history-month-content"></div>
        `;

        const monthContent = monthDiv.querySelector(".history-month-content");

        // Render workouts inside month
        groups[year][month].forEach(workout => {
          const workoutDiv = document.createElement("div");
          workoutDiv.className = "history-workout";

          workoutDiv.innerHTML = `
            <div class="history-workout-header">
              <span>${workout.workoutName} — ${workout.date}</span>
              <span class="history-arrow">▶</span>
            </div>

            <div class="history-workout-content">
              ${workout.exercises.map(ex => `
                <div class="history-exercise">
                  <strong>${ex.name}</strong>
                  <ul>
                    ${ex.sets.map(s => `
                    <li class="history-set">
                    ${
                      ex.type === "time-weight"
                        ? `${s.time} sec × ${s.weight} kg`
                        : `${s.reps} reps × ${s.weight} kg`
                    }
                    </li>

                    `).join("")}
                  </ul>
                  ${ex.note ? `<p><em>${ex.note}</em></p>` : ""}
                </div>
              `).join("")}
            </div>
          `;

          monthContent.appendChild(workoutDiv);
        });

        yearContent.appendChild(monthDiv);
      });

      container.appendChild(yearDiv);
    });

    // Collapsible logic (year, month, workout)
    document.querySelectorAll(".history-year-header, .history-month-header, .history-workout-header")
      .forEach(header => {
        header.addEventListener("click", () => {
          const content = header.nextElementSibling;
          const arrow = header.querySelector(".history-arrow");

          const open = content.style.display === "block";
          content.style.display = open ? "none" : "block";
          arrow.classList.toggle("open", !open);
        });
      });
  }

// Load strength progress chart
let chartInstance = null;

async function loadStrengthProgress() {
  const user = auth.currentUser;
  if (!user) return;

  const snapshot = await db.collection("users")
    .doc(user.uid)
    .collection("workouts")
    .orderBy("date", "asc")
    .get();

  const dataPoints = [];

  snapshot.forEach(doc => {
    const workout = doc.data();

    workout.exercises.forEach(ex => {

      // Skip timed exercises — they do NOT belong in the strength chart
      if (ex.type === "time-weight") return;

      // Strength PR = max weight
      const maxWeight = Math.max(...ex.sets.map(s => s.weight || 0));

      dataPoints.push({
        date: workout.date,
        exercise: ex.name,
        weight: maxWeight
      });
    });
  });

  return dataPoints;
}

async function loadBodyGroupUsage() {
  const user = auth.currentUser;
  if (!user) return;

  const snapshot = await db.collection("users")
    .doc(user.uid)
    .collection("workouts")
    .get();

  const groups = {
    Chest: 0, Back: 0, Shoulders: 0, Biceps: 0,
    Triceps: 0, Legs: 0, Core: 0, Other: 0
  };

  const EXERCISE_CATEGORIES = {
    Chest: ["Bench Press", "Incline Dumbbell Press", "Chest Fly", "Push-Up"],
    Back: ["Deadlift", "Lat Pulldown", "Barbell Row", "Seated Row"],
    Shoulders: ["Overhead Press", "Lateral Raise", "Front Raise", "Rear Delt Fly"],
    Biceps: ["Barbell Curl", "Hammer Curl", "Preacher Curl"],
    Triceps: ["Tricep Pushdown", "Skullcrusher", "Overhead Extension"],
    Legs: ["Squat", "Leg Press", "Lunges", "Leg Extension", "Hamstring Curl"],
    Core: ["Plank", "Cable Crunch", "Hanging Leg Raise"]
  };

  snapshot.forEach(doc => {
    const workout = doc.data();

    workout.exercises.forEach(ex => {
      let found = false;

      for (const group in EXERCISE_CATEGORIES) {
        if (EXERCISE_CATEGORIES[group].includes(ex.name)) {
          groups[group]++;
          found = true;
          break;
        }
      }

      if (!found) groups.Other++;
    });
  });

  return groups;
}

async function renderChart(type) {
  const ctx = document.getElementById("progressChart").getContext("2d");

  if (chartInstance) chartInstance.destroy();

  /* -----------------------------
     STRENGTH PROGRESSION (LINE)
  ------------------------------ */
  if (type === "strength") {
    const data = await loadStrengthProgress();

    chartInstance = new Chart(ctx, {
      type: "line",
      data: {
        labels: data.map(d => d.date),
        datasets: [{
          label: "Max Weight (kg)",
          data: data.map(d => d.weight),
          borderColor: "#f9d423",
          backgroundColor: "rgba(249,212,35,0.25)",
          borderWidth: 4,
          pointRadius: 5,
          pointBackgroundColor: "#f9d423",
          tension: 0.35
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          title: {
            display: true,
            text: "Strength Progression",
            color: "#fff",
            font: { size: 22, weight: "bold" },
            padding: 20
          },
          legend: {
            labels: {
              color: "#fff",
              font: { size: 14 }
            }
          }
        },
        scales: {
          x: {
            ticks: { color: "#fff", font: { size: 12 } },
            grid: { color: "rgba(255,255,255,0.08)" }
          },
          y: {
            ticks: { color: "#fff", font: { size: 14 } },
            grid: { color: "rgba(255,255,255,0.15)" }
          }
        }
      }
    });
  }

  /* -----------------------------
     BODY GROUP USAGE (PIE)
  ------------------------------ */
  if (type === "bodygroups") {
    const groups = await loadBodyGroupUsage();

    chartInstance = new Chart(ctx, {
      type: "pie",
      data: {
        labels: Object.keys(groups),
        datasets: [{
          data: Object.values(groups),
          backgroundColor: [
            "#ff4e50", "#f9d423", "#4CAF50", "#2196F3",
            "#9C27B0", "#FF9800", "#00BCD4", "#9E9E9E"
          ],
          borderColor: "#222",
          borderWidth: 2
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          title: {
            display: true,
            text: "Most Used Body Groups",
            color: "#fff",
            font: { size: 22, weight: "bold" },
            padding: 20
          },
          legend: {
            position: "bottom",
            labels: {
              color: "#fff",
              font: { size: 14 }
            }
          }
        }
      }
    });
  }
}

document.getElementById("chartSelector").addEventListener("change", (e) => {
  renderChart(e.target.value);
});

    // Auto-set today's date
    document.addEventListener("DOMContentLoaded", () => {
      const today = new Date().toISOString().split("T")[0];
      document.getElementById("workoutDate").value = today;

      // Restore workout name
      const savedName = localStorage.getItem("workoutName");
      if (savedName) {
        document.getElementById("workoutName").value = savedName;
      }

      // Save workout name as user types
      document.getElementById("workoutName").addEventListener("input", () => {
        localStorage.setItem("workoutName", document.getElementById("workoutName").value);
      });

      const stored = JSON.parse(localStorage.getItem("selectedExercises"));
      if (stored) {
        selectedExercises = stored;
        updateSelectedExercises();
      }
    });

    let selectedExercises = [];

    // Render exercises with sets
function updateSelectedExercises() {
  const container = document.getElementById("selectedExercisesList");
  container.innerHTML = "";

  selectedExercises.forEach((ex, index) => {

    const div = document.createElement("div");
    div.className = "exercise-entry-block";

    div.innerHTML = `
      <h3>${ex.name}</h3>
      ${ex.note ? `<p><em>Note: ${ex.note}</em></p>` : ""}

      <div class="sets-container" id="sets-${index}">
        ${ex.sets.map((s, i) => `
          <div class="set-row ${s.completed ? "set-completed" : ""}">
            <span class="set-number">Set ${i + 1}</span>

              ${
                ex.type === "time-weight"
                  ? `
                    <div class="set-input-group">
                      <label>Time (sec)</label>
                      <input 
                        type="number"
                        value="${s.time || ""}"
                        class="set-time"
                        placeholder="0"
                        ${s.completed ? "disabled" : ""}
                      >
                    </div>

                    <div class="set-input-group">
                      <label>Weight (kg)</label>
                      <input 
                        type="number"
                        value="${s.weight ?? 0}"
                        class="set-weight"
                        placeholder="0"
                        ${s.completed ? "disabled" : ""}
                      >
                    </div>
                  `
                  : `
                    <div class="set-input-group">
                      <label>Reps</label>
                      <input 
                        type="number"
                        value="${s.reps || ""}"
                        class="set-reps"
                        placeholder="0"
                        ${s.completed ? "disabled" : ""}
                      >
                    </div>

                    <div class="set-input-group">
                      <label>Weight (kg)</label>
                      <input 
                        type="number"
                        value="${s.weight || ""}"
                        class="set-weight"
                        placeholder="0"
                        ${s.completed ? "disabled" : ""}
                      >
                    </div>
                  `
              }


            <button class="btn-complete-set" onclick="toggleSetComplete(${index}, ${i})">
              ${s.completed ? "✔" : "✓"}
            </button>

            <img src="images/trophyIcon.png" 
                 class="pr-badge ${s.isPR ? "pr-hit" : ""}" 
                 id="pr-${index}-${i}" />

            <span class="new-pr-label ${s.isPR ? "show" : ""}" 
                  id="newpr-${index}-${i}">
              ${s.isPR ? "NEW PR!" : ""}
            </span>

            <button class="btn-remove-set" onclick="removeSet(${index}, ${i})">✕</button>
          </div>
        `).join("")}
      </div>

      <button class="btn-secondary" onclick="addSet(${index})">+ Add Set</button>
      <button class="btn-secondary" onclick="duplicateLastSet(${index})">Duplicate Last Set</button>
      <button class="btn-remove" onclick="removeExercise(${index})">Remove Exercise</button>
    `;

    container.appendChild(div);
  });
}

    function addSet(exIndex) {
      // Save current input values BEFORE re-rendering
      syncSetInputs();

        if (selectedExercises[exIndex].type === "time-weight") {
          selectedExercises[exIndex].sets.push({
            time: "",
            weight: 0 // bodyweight default
          });
        } else {
          selectedExercises[exIndex].sets.push({
            reps: "",
            weight: ""
          });
        }


      localStorage.setItem("selectedExercises", JSON.stringify(selectedExercises));
      updateSelectedExercises();
    }

    // Duplicate last set
    function duplicateLastSet(exIndex) {
      // Save current input values BEFORE re-rendering
      syncSetInputs();

      const last = selectedExercises[exIndex].sets.at(-1);
      if (!last) return;

      if (selectedExercises[exIndex].type === "time-weight") {
        selectedExercises[exIndex].sets.push({
          time: last.time,
          weight: last.weight
        });
      } else {
        selectedExercises[exIndex].sets.push({
          reps: last.reps,
          weight: last.weight
        });
      }

      localStorage.setItem("selectedExercises", JSON.stringify(selectedExercises));
      updateSelectedExercises();
    }
    // Toggle set complete
function toggleSetComplete(exIndex, setIndex) {
  syncSetInputs();

  const set = selectedExercises[exIndex].sets[setIndex];
  set.completed = !set.completed;

  localStorage.setItem("selectedExercises", JSON.stringify(selectedExercises));
  updateSelectedExercises();

  // Only trigger PR when completing a set with weight
  if (set.completed && set.weight > 0) {
    checkPRIndicators(true);
  }
}


    // Remove a set
    function removeSet(exIndex, setIndex) {
      syncSetInputs();

      selectedExercises[exIndex].sets.splice(setIndex, 1);

      localStorage.setItem("selectedExercises", JSON.stringify(selectedExercises));
      updateSelectedExercises();
    }

    // Remove an exercise
      function removeExercise(index) {
        syncSetInputs();

        selectedExercises.splice(index, 1);

        localStorage.setItem("selectedExercises", JSON.stringify(selectedExercises));
        updateSelectedExercises();
      }

    // Sync input fields into selectedExercises before saving
function syncSetInputs() {
  selectedExercises.forEach((ex, exIndex) => {
    const rows = document.querySelectorAll(`#sets-${exIndex} .set-row`);

    ex.sets = [...rows].map((row, i) => {
    if (ex.type === "time-weight") {
      return {
        time: Number(row.querySelector(".set-time").value),
        weight: Number(row.querySelector(".set-weight").value) || 0,
        completed: ex.sets[i].completed || false,
        isPR: ex.sets[i].isPR || false
      };
    }


      return {
        reps: Number(row.querySelector(".set-reps").value),
        weight: Number(row.querySelector(".set-weight").value),
        completed: ex.sets[i].completed || false,
        isPR: ex.sets[i].isPR || false
      };
    });
  });

  localStorage.setItem("selectedExercises", JSON.stringify(selectedExercises));
}


    // Navigate to selector
    document.getElementById("openExerciseSelector").addEventListener("click", () => {
      window.location.href = "exercise-selector.html";
    });

    // Update PRs and return a list of new PRs hit
async function updatePRs(exercises, date) {
  const user = auth.currentUser;
  if (!user) return [];

  const newPRs = []; // store PR hits for animations/toasts

  for (const ex of exercises) {
    if (!ex.sets || ex.sets.length === 0) continue;

    // Determine PR value based on exercise type
    const maxValue = ex.type === "time-weight"
      ? Math.max(...ex.sets.map(s => s.time || 0))
      : Math.max(...ex.sets.map(s => s.weight || 0));

    const prRef = db.collection("users")
      .doc(user.uid)
      .collection("personalRecords")
      .doc(ex.name);

    const prDoc = await prRef.get();
    const oldPR = prDoc.exists ? prDoc.data().weight : 0;

    // If new PR hit
    if (maxValue > oldPR) {
      await prRef.set({
        weight: maxValue, // still stored as "weight" for simplicity
        date
      });

      newPRs.push({
        name: ex.name,
        weight: maxValue
      });
    }
  }

  return newPRs; // return list of PRs hit
}

      // Load PRs (with trophy + clean formatting)
      async function loadPRs() {
      const user = auth.currentUser;
      if (!user) return;

      const snapshot = await db.collection("users")
        .doc(user.uid)
        .collection("personalRecords")
        .get();

      const container = document.getElementById("prCategories");
      container.innerHTML = "";

      if (snapshot.empty) {
        container.innerHTML = `<p style="color:#aaa;">No PRs yet — go set some records!</p>`;
        return;
      }

      // Build category structure
      const categories = {};
      snapshot.forEach(doc => {
        const name = doc.id;
        const data = doc.data();
        const weight = data.weight;

        // Find category
        let category = "Other";
        for (const cat in EXERCISE_CATEGORIES) {
          if (EXERCISE_CATEGORIES[cat].includes(name)) {
            category = cat;
            break;
          }
        }

        if (!categories[category]) categories[category] = [];
        categories[category].push({ name, weight });
      });

      // Render categories
      for (const category in categories) {
        const block = document.createElement("div");
        block.className = "pr-category";

        block.innerHTML = `
          <div class="pr-category-header">
            <span>${category}</span>
            <span class="pr-arrow">▶</span>
          </div>

          <div class="pr-category-content">
            ${categories[category].map(pr => `
              <div class="pr-item">
                <span class="pr-item-name">${pr.name}</span>
                <span class="pr-item-weight">
                ${
                  TIMED_EXERCISES.includes(pr.name)
                    ? `${pr.weight} sec`
                    : `${pr.weight} kg`
                }
              </span>
              </div>
            `).join("")}
          </div>
        `;

        container.appendChild(block);
      }

      // Collapsible logic
      document.querySelectorAll(".pr-category-header").forEach(header => {
        header.addEventListener("click", () => {
          const content = header.nextElementSibling;
          const arrow = header.querySelector(".pr-arrow");

          const isOpen = content.style.display === "block";
          content.style.display = isOpen ? "none" : "block";
          arrow.classList.toggle("open", !isOpen);
        });
      });

      // Search logic
      document.getElementById("prSearch").addEventListener("input", e => {
        const term = e.target.value.toLowerCase();

        document.querySelectorAll(".pr-item").forEach(item => {
          const name = item.querySelector(".pr-item-name").textContent.toLowerCase();
          item.style.display = name.includes(term) ? "flex" : "none";
        });
      });
    }

    // Check and show PR indicators

      // Prevent toast spam
      let prToastCooldown = false;

      // Check and show PR indicators
async function checkPRIndicators(triggeredByCompletion = false) {
  const user = auth.currentUser;
  if (!user) return;

  // Load PRs
  const prSnapshot = await db.collection("users")
    .doc(user.uid)
    .collection("personalRecords")
    .get();

  const prMap = {};
  prSnapshot.forEach(doc => {
    prMap[doc.id] = doc.data().weight;
  });

  selectedExercises.forEach((ex, exIndex) => {
    const currentPR = prMap[ex.name] || 0;

    // Find the heaviest set for this exercise
    const maxSetWeight = Math.max(...ex.sets.map(s => s.weight));

    ex.sets.forEach((set, setIndex) => {
      const badge = document.getElementById(`pr-${exIndex}-${setIndex}`);
      const label = document.getElementById(`newpr-${exIndex}-${setIndex}`);
      if (!badge) return;

      const isMaxSet = set.weight === maxSetWeight;

      /* ---------------------------------------------------------
         ONLY UPDATE PR STATE IF THIS WAS TRIGGERED BY COMPLETION
         --------------------------------------------------------- */
      if (triggeredByCompletion) {
        if (isMaxSet && maxSetWeight > currentPR) {
          set.isPR = true;   // store PR state
        } else {
          set.isPR = false;
        }
      }

      /* ---------------------------------------------------------
         ALWAYS DISPLAY PR STATE FROM STORED VALUE (set.isPR)
         --------------------------------------------------------- */
      if (set.isPR) {
        badge.classList.add("pr-hit");

        if (label) {
          label.textContent = "NEW PR!";
          label.classList.add("show");
        }

        // Only fire celebration when triggered by completion
        if (triggeredByCompletion && !prToastCooldown) {
          prToastCooldown = true;

          const rect = badge.getBoundingClientRect();
          spawnConfetti(rect.x + 10, rect.y + 10);

          const sound = document.getElementById("prSound");
          if (sound) sound.play();

          showPRToast(
            ex.name,
            ex.type === "time-weight" ? `${set.time} sec` : `${set.weight} kg`
          );


          setTimeout(() => prToastCooldown = false, 1500);
        }

      } else {
        // Remove visuals if not PR
        badge.classList.remove("pr-hit");
        if (label) label.classList.remove("show");
      }
    });
  });
}

    // Show PR Toast
    function showPRToast(exName, weight) {
    const toast = document.getElementById("prToast");
    toast.textContent = `New PR on ${exName}! ${weight} kg`;
    toast.classList.add("show");

    setTimeout(() => toast.classList.remove("show"), 2000);
    }

    // Confetti effect
    function spawnConfetti(x, y) {
  for (let i = 0; i < 8; i++) {
    const dot = document.createElement("div");
    dot.className = "confetti-dot";
    document.body.appendChild(dot);

    dot.style.left = x + "px";
    dot.style.top = y + "px";

    const angle = Math.random() * 2 * Math.PI;
    const distance = 40 + Math.random() * 20;

    dot.animate([
      { transform: "translate(0,0)", opacity: 1 },
      { transform: `translate(${Math.cos(angle)*distance}px, ${Math.sin(angle)*distance}px)`, opacity: 0 }
    ], { duration: 600 });

    setTimeout(() => dot.remove(), 600);
  }
}

    // Save workout
    document.getElementById("saveWorkoutBtn").addEventListener("click", async () => {
      const user = auth.currentUser;
      if (!user) return alert("Not logged in");

      const date = document.getElementById("workoutDate").value;
      if (!date) return alert("Select a date");
      if (selectedExercises.length === 0) return alert("Add at least one exercise");

      syncSetInputs(); // IMPORTANT

      const workoutName = document.getElementById("workoutName").value.trim();

      await db.collection("users").doc(user.uid).collection("workouts").add({
        workoutName: workoutName || date, // fallback if empty
        date, // keep date for sorting
        exercises: selectedExercises,
        timestamp: firebase.firestore.FieldValue.serverTimestamp()
      });

      await updatePRs(selectedExercises, date);

      alert("Workout saved!");

      selectedExercises = [];
      localStorage.removeItem("selectedExercises");
      updateSelectedExercises();

      loadWorkoutHistory();
      loadStrengthProgress();
      loadPRs();
    });

    // Auth state
    auth.onAuthStateChanged(user => {
      if (!user) {
        document.getElementById("accessBlocker").style.display = "flex";
      } else {
        document.getElementById("accessBlocker").style.display = "none";
        loadUserName();
        loadWorkoutHistory();
        loadStrengthProgress();
        loadPRs();

        // Load default chart
        renderChart("strength");

      }
    });
  </script>

</body>

<page-footer>
  <a>Made by Adam Dimkovski</a><br>
  <footer-text>Litness</footer-text>
</page-footer>

</html>